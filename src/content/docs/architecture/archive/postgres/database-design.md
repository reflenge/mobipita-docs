---
title: データベース設計
description: マルチテナントDBの設計パターン（RLS と Schema分離）

---

## Archived

このページは **Postgres / RLS / スキーマ分離**の過去案です。
現在の採用方針は Convex のため、参考資料として保存しています。

- 現在の結論: /architecture/stack/current
- 現行の設計指針: /architecture/db/database-design

---


結論から言うと、**現代の一般的なSaaSやプラットフォーム開発では「物理的には分けず、論理的に分ける（共有する）」のが主流**です。これを「マルチテナントアーキテクチャ」と呼びます。

ただし、「絶対に分けてはいけない」わけではなく、セキュリティ要件やコストによって3つのパターンから選択します。

以下に、それぞれの設計パターンと、**DB・Storage・Auth**それぞれの具体的な扱い方を解説します。

---

### 1. 主な3つの設計パターン

#### A. プールモデル（完全共有・論理分離） ★推奨・主流
* **仕組み:** 全テナントが**同じDB、同じストレージ**を使います。
* **区別方法:** 全てのデータに `tenant_id` （テナントID）というタグをつけて、「A社のデータはA社しか見れない」ようにプログラムやDBの機能で制御します。
* **メリット:** コストが最も安い。運用が楽（DBのバージョンアップが1回で済む）。
* **デメリット:** プログラムのバグで「他社のデータが見えてしまう」リスクがある（実装でカバー可能）。

#### B. サイロモデル（完全分離・物理分離）
* **仕組み:** テナントごとに**個別のDBインスタンス、個別のストレージ**を用意します。
* **メリット:** セキュリティが最強。A社の負荷がB社に影響しない。
* **デメリット:** コストが激増する。1000社いたら1000個のDBを管理・更新する必要があり、運用が地獄になる。
* **用途:** 銀行、医療、官公庁向けなど、極めて厳しいセキュリティ要件がある場合のみ。

#### C. ブリッジモデル（ハイブリッド）
* **仕組み:** DBのサーバーは一緒だが、「スキーマ（Databaseの中の部屋）」だけ分ける。
* **立ち位置:** AとBの中間。PostgreSQLなどでよく使われますが、最近はAの技術進化により減りつつあります。

---

### 2. 各コンポーネントごとの具体的な分け方（プールモデルの場合）

モダンな開発（Next.js, Supabase/Postgres, Clerkなど）を前提に、最も一般的な構成を説明します。

#### ① DB (Database)
* **物理構成:** 1つのデータベースを使用。
* **設計:** 全テーブルに `tenant_id` カラムを持たせます。
* **セキュリティ:**
    * **昔:** アプリのコードで `WHERE tenant_id = 'xxx'` を毎回書く（忘れがちで危険）。
    * **今:** **RLS (Row Level Security)** というDBの機能を使います。「ログイン中のユーザーの所属テナントIDと一致する行しか、DBレベルで返さない」という設定ができるため、アプリ側のミスでデータ漏洩することがなくなりました。

#### ② Storage (画像・ファイル)
* **物理構成:** AWS S3 などの1つのバケットを使用。
* **設計:** フォルダ（プレフィックス）で分けます。
    * 例: `/bucket-name/{tenant_id}/user-icon.png`
* **セキュリティ:** DB同様、ストレージのアクセスポリシーで「自分の `tenant_id` フォルダ以外はアクセス不可」に設定します。

#### ③ Auth (認証)
* **物理構成:** 1つの認証基盤（Auth0, Clerk, Cognitoなど）を使用。**テナントごとに認証サーバーを立てることはまずありません。**
* **設計:** 「ユーザー」と「組織（Organization/Team）」の概念を使います。
    * 1人のユーザーが複数のテナント（組織）に所属することも考慮します（Slackのワークスペース切り替えのようなイメージ）。
* **実装:** ログイン時に「どのテナントとしてログインするか」を選択させ、そのセッション中に `tenant_id` を保持し続けます。

---

### 3. どちらを選ぶべきか？

**基本的には「プールモデル（共有）」でスタートすることを強くお勧めします。**

理由は以下の通りです：

1.  **初期コスト:** テナントごとにインフラを立ち上げると、売上がないうちからインフラ費が嵩みます。
2.  **開発速度:** テナント作成のたびにAWS/GCPのAPIを叩いてリソースを作る処理を書くのは、非常に難易度が高いです。
3.  **スケーラビリティ:** `tenant_id` で分ける方式なら、数万テナントまでは同じ構成で耐えられます。

### 4. 実際のデータ構造イメージ（DB）

**users テーブル（全ユーザー共有）**
| id | email | name |
| :--- | :--- | :--- |
| u_1 | user@a.com | Alice |
| u_2 | user@b.com | Bob |

**tenants テーブル（店舗・企業）**
| id | name | plan |
| :--- | :--- | :--- |
| t_A | 株式会社A | Pro |
| t_B | 株式会社B | Free |

**orders テーブル（ここに `tenant_id` が入る）**
| id | **tenant_id** | amount | product |
| :--- | :--- | :--- | :--- |
| o_1 | **t_A** | 1000 | 椅子 |
| o_2 | **t_B** | 5000 | 机 |
| o_3 | **t_A** | 2000 | 棚 |

こうすることで、`SELECT * FROM orders WHERE tenant_id = 't_A'` とすれば、株式会社Aの注文だけが取得できます。

---

## PostgreSQLにおける実装パターン

PostgreSQLを採用する場合、現代のマルチテナント開発のデファクトスタンダード（事実上の標準）は、**「Row Level Security (RLS) を使ったプールモデル」**です。

これは、PostgreSQLがデータベースエンジンレベルで持っている強力なセキュリティ機能を利用する方法で、アプリケーションのコード（WHERE句）でのバグによるデータ漏洩を「強制的に」防ぐことができます。

データベース選定の詳細は[データベース選定](/architecture/db/database-selection)を参照してください。

以下に、PostgreSQLにおける概念、RLSの仕組み、そしてもう一つの選択肢であるスキーマ分離について解説します。

### 1\. 推奨：Row Level Security (RLS) パターン

**「全てのデータを1つの箱に入れ、RLSというセキュリティ機能により、各ユーザーには自分のデータしか見えなくする」** というアプローチです。SupabaseなどのモダンなBackend-as-a-Serviceもこの仕組みを採用しています。

#### 概念と設計思想

  * **物理構成:** 1つのデータベース、1つのスキーマ（`public`など）。
  * **論理構成:** 全テーブルに `tenant_id` カラムを追加。
  * **セキュリティ:** アプリケーションがSQLを投げる前に、「今のユーザーはテナントAの人です」とDBに伝えます。すると、DBは自動的にテナントAのデータだけをフィルタリングして返します。`SELECT * FROM orders` と書いても、他社のデータは物理的に存在しないかのように振る舞います。

#### 実装手順（SQLイメージ）

1.  **テーブル作成:** `tenant_id` を持たせます。

    ```sql
    CREATE TABLE orders (
      id SERIAL PRIMARY KEY,
      tenant_id UUID NOT NULL, -- これが重要
      product_name TEXT
    );
    ```

2.  **RLSの有効化:** このテーブルでセキュリティ機能をONにします。

    ```sql
    ALTER TABLE orders ENABLE ROW LEVEL SECURITY;
    ```

3.  **ポリシーの作成（ここが心臓部）:**
    「`tenant_id` カラムが、現在のセッション設定 `app.current_tenant` と一致する行のみを表示する」というルールを作成します。

    ```sql
    CREATE POLICY tenant_isolation_policy ON orders
    USING (tenant_id = current_setting('app.current_tenant')::UUID);
    ```

4.  **実際の利用フロー:**
    アプリ側（APIサーバー）でクエリを投げる際、必ず最初に「テナントIDのセット」を行います。

    ```sql
    -- 1. トランザクション開始
    BEGIN;
    -- 2. 今のアクセスはテナントID '123' のものだと宣言
    SET LOCAL app.current_tenant = '123';
    -- 3. 普通に全件取得しようとする
    SELECT * FROM orders;
    -- 4. 結果: テナントID '123' のデータしか返ってこない！
    COMMIT;
    ```

### 2\. もう一つの選択肢：Schema（スキーマ）分離パターン

PostgreSQL特有の機能である「Schema（名前空間）」を利用して、**「テナントごとに部屋を分ける」** アプローチです。

#### 概念と設計思想

  * **物理構成:** 1つのデータベース。
  * **論理構成:** テナントごとにスキーマを作成します（例: `tenant_a.orders`, `tenant_b.orders`）。
  * **仕組み:** PostgreSQLの `search_path` という機能を使い、「今は `tenant_a` の部屋を見る」と設定すると、`SELECT * FROM orders` と書くだけで自動的に `tenant_a.orders` を見に行きます。

#### メリットとデメリット（RLSとの比較）

| 特徴 | RLS（行レベルセキュリティ） | Schema分離 |
| :--- | :--- | :--- |
| **データ分離強度** | 高（設定ミスさえなければ安全） | **最高**（部屋自体が違うので混ざりようがない） |
| **マイグレーション** | **楽**（1回コマンドを打てば全テナントに反映） | **地獄**（テナント数分ループして実行が必要） |
| **スケーラビリティ** | 数万〜数百万テナントでもOK | 数千テナントを超えるとDBの動作が重くなる可能性あり |
| **開発ツール対応** | Drizzle, Prisma等で扱いやすい | ツールによっては対応が複雑 |

### 3\. 結論：どちらを選ぶべきか

**95%のケースで、1番の「RLSパターン」をおすすめします。**

  * **理由1:** マイグレーション（DB構造の変更）が圧倒的に楽だからです。スキーマ分離を選ぶと、「カラムを1つ追加したいだけなのに、スクリプトを書いて1000個のスキーマに対してループ処理を実行し、途中でエラーが出たら...」という運用リスクを抱えることになります。
  * **理由2:** エコシステムがRLS前提になりつつあるからです（Supabaseなど）。

**スキーマ分離を選ぶべき例外:**

  * 「A社専用のデータを丸ごとバックアップして渡してほしい」という要望が頻繁にある場合。
  * テナントごとにテーブル構造そのものを変える必要がある場合（極めて稀）。

---

## ORMとの連携

PostgreSQLを操作するために、**ORM（Object-Relational Mapping）**の選定が必要です。

選択するORMによって、RLSやテナント分離をコード上でどう実装するかが変わります。

詳細は[ORM選定](/architecture/db/orm-selection)を参照してください。

:::tip[実装前の検討事項]
以下の点は実装前に確定する必要があります：
- ORMの最終選定（Drizzle ORM / Prisma / TypeORM）
- RLSの採用可否（Supabase使用時は推奨）
- テナントIDの取得方法（認証情報から / サブドメインから / ヘッダーから）
- マイグレーション戦略
- バックアップ・リストアの方法

これらは実装フェーズで詳細化される予定です。
:::
